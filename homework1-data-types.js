/* 
1)  'number' + 3 + 3 
Після невдачі привести string 'number' до числового значення відбудеться конкатинація (склеювання) значень.
Тож результатом буде строка 'number33'

2)  null + 3
JS буде намагатись привести null до числа, null -> false -> 0
Тож результатом сумми 0 + 3 буде число 3 з типом number.

3)  5 && "qwerty"
Оператор AND повертає найперше значення false, в іншому випадку поверне останнє з циклу.
Число 5 - це true, стрінг 'qwerty' теж true, тож поверне останній вираз - це 'qwerty'

4)  +'40' + +'2' + "hillel";
Плюс перед строковими значеннями '40' та '2' змінить їх тип данних на числове - number.
Далі виконається додавання чисел 40 та 2, а до суми приклеїться (конкатинація) слово "hillel".
Вийде строка "42hillel"

5)  '10' - 5 === 6;
Спочатку виконається віднімання вже приведеної до числа строки '10' та числа 5. Вийде 5, тип number.
Потім будуть порівнюватись значення та тип чисел 5 і 6. Тип однаковий, але значення не дорівнють один одному.
Тому результат false, тип boolean.

6)  true + false
JS приведе до числа і додасть 1 та 0. Буде 1, number.

7)  '4px' - 3
JS не зможе привести строку '4px' до числового значення і в результаті отримаємо
NaN, тип number.


8)  '4' - 3
Строка '4' стане числом 4, а результатом віднімання буде 1, тип number.

9)  '6' + 3 ** 0;
Спершу виконається дія - приведення до степеня 0 числа 3. Результат одиниця.
Потім строка '6' поєднається (конкатинація) з числом 1 і стане строкою "61".

10)  12 / '6'
Строка '6' стане числом 6 і в результаті ділення буде 2, тип number.

11)  '10' + (5 === 6);
Спочатку зробиться дія у дужках - результатом порівняння по значенню і типу данних у цьому випадку буде false, тип boolean.
Далі відбудеться конкатинація строки '10' та булевого значення false, в результаті отримаємо строку '10false'

12)  null == ''
Відбудеться порівняння значеннь на рівність один одному. 
Реузультат false, тип boolean.


13)  3 ** (9 / 3);
Спочатку буде дія ділення у дужках, а потім приведення до степеня 3 числа 3.
Результат 27, тип number.

14)  !!'false' == !!'true'
Подвійне NOT для непустої строки видасть true.
Тож порівнюється на рівність значення true та true.
Відповідь буде true, тип boolean

15)  0 || '0' && 1
Спершу виконається дія "I" справа '0' && 1. Непуста строка true та 1 - це  теж true. Видасть останній вираз - це 1 number.
Далі будуть порівнюватись "АБО"   0 || 1. Перший вираз 0 - це false, то поверне другий вираз - 1, тип number.

16)  (+null == false) < 1;
Спочатку дужки. Приведе +null до числа 0. Порівняє число 0 по значенню з false, що теж дорівнює нулю і видасть true, тип boolean.
Далі виконає порівняння менше, де 1 < 1 видасть false, тип boolean.


17)  false && true || true
Спершу дія false && true (більший пріорітет перед OR)- це буде перше false, тип boolean.
Далі true || true, видасть перше true, тип boolean.

18)  false && (false || true);
Спершу дія в дужкаж - видасть true, тип boolean.
При другому - false, тип boolean.

19)  (+null == false) < 1 ** 5; 

Спочатку дужки. Приведе +null до 0. Порівняє число 0 по значенню з false, що теж дорівнює нулю і видасть true, тип boolean.
Далі виконає дію приведення до степеня 1 ** 5 = 1, тип number.
Потім порівняє true < 1 та видасть false, тип boolean. 
*/